/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package pdf;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;

public class App {
    private static PDDocument pdDocument;
    private static PDFTextStripper pdfStripper;
    private static Map<String, Integer> pageNumberMap = new HashMap<String, Integer>();
    private static Map<String, Instruction> instrMap = new HashMap<String, Instruction>();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        try {
            pdDocument = PDDocument.load(new File("app/src/main/resources/atmel-0856-avr-instruction-set-manual.pdf"));
            pdfStripper = new PDFTextStripper();
            pdfStripper.setSortByPosition(true);

            initPageNumberMap();
            initCommandMap();

            while (true) {
                System.out.println("Tekan 1 untuk menampilkan Summary Instruksi AVR");
                System.out.println("Tekan 2 untuk konversi ke Machine Code");
                System.out.println("Tekan 99 untuk exit.");
                String in = scanner.nextLine();
                if (in.equals("1")) {
                    System.out.print("Instruksi: ");
                    System.out.println(instrMap.get(scanner.nextLine().toUpperCase()));
                } else if (in.equals("2")){
                    System.out.print("Instruksi: ");
                    String masukan = scanner.nextLine().toUpperCase();
                    String cmd = masukan.split("\s")[0];
                    System.out.println(instrMap.get(cmd).toMachineCode(masukan));
                } else {
                    System.out.println("keluar dari program...");
                    break;
                }
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static ArrayList<Syntax> extractSyntax(String text, String command) {
        text = text.replace(", ", ",");
        Pattern patternWithArgument = Pattern.compile("\\([i]+[v]?\\)\\s(" + command + "\\s[RdXYZ,r\\+-kK]*?)\\s+");
        Pattern patternNoArgument = Pattern.compile("\\([i]+[v]?\\)\\s(" + command + ")\\s+None");
        ArrayList<Syntax> syntaxList = new ArrayList<Syntax>();
        ArrayList<String> opCodes = extractOpCode(text);
        Iterator<String> opCodesIterator = opCodes.iterator();
        Matcher matcher = patternNoArgument.matcher(text);
        while (matcher.find() && opCodesIterator.hasNext()) {
            // return (matcher.group(1));
            String syntax = matcher.group(1);
            syntaxList.add(new Syntax0Args(syntax, opCodesIterator.next()));
        }

        matcher = patternWithArgument.matcher(text);
        while (matcher.find() && opCodesIterator.hasNext()) {
            // return (matcher.group(1));
            String syntax = matcher.group(1);
            String[] args = new String[0];
            try {
                args = syntax.split("\\s")[1].split(",");
            } catch (ArrayIndexOutOfBoundsException e) {
            }
            if (args.length == 1 && args[0].equals("NONE")){
                syntaxList.add(new Syntax0Args(syntax, opCodesIterator.next()));
            }
            if (args.length == 0){
                syntaxList.add(new Syntax0Args(syntax, opCodesIterator.next()));
            } else if (args.length == 1){
                syntaxList.add(new Syntax1Args(syntax, opCodesIterator.next(), Argument.getArgument(args[0])));
            } else if (args.length == 2) {
                syntaxList.add(new Syntax2Args(syntax, opCodesIterator.next(), Argument.getArgument(args[0]), Argument.getArgument(args[1])));
            }
        }
        return syntaxList;
    }

    private static ArrayList<String> extractOpCode(String text) {
        String charInOpcode = "[01rdkK]";
        Pattern pattern = Pattern.compile(charInOpcode + "{4}\\s" + charInOpcode + "{4}\\s" + charInOpcode + "{4}\\s" + charInOpcode + "{4}");
        Matcher matcher = pattern.matcher(text);
        ArrayList<String> opCodes = new ArrayList<String>();
        while (matcher.find()) {
            opCodes.add(matcher.group());
        }
        return opCodes;
    }

    private static String extractDescription(String text) {
        Pattern pattern = Pattern.compile("Description\\n+([\\s\\S]+?)Operation:");
        Matcher matcher = pattern.matcher(text);
        if (matcher.find()) {
            return (matcher.group(1).replace('\n', ' '));
        }
        return null;

    }

    private static void initCommandMap() throws IOException {
        for (var entry : pageNumberMap.entrySet()) {
            pdfStripper.setStartPage(entry.getValue());
            pdfStripper.setEndPage(entry.getValue());
            if (!pageNumberMap.values().contains(entry.getValue() + 1)){
                pdfStripper.setEndPage(entry.getValue() + 1);
            }
            String text = pdfStripper.getText(pdDocument);
            var syntaxList = extractSyntax(text, entry.getKey());
            var newInstr = new Instruction(extractDescription(text));
            instrMap.put(entry.getKey(), newInstr);
            for (Syntax syntax : syntaxList) {
                newInstr.addSyntax(syntax);
            }
        }
    }

    private static void initPageNumberMap() throws IOException {
        Pattern pattern = Pattern.compile("\\s\\d+\\.\\s.+?(\\d+)");
        pdfStripper.setStartPage(2);
        pdfStripper.setEndPage(12);
        String text = pdfStripper.getText(pdDocument);
        Matcher matcher = pattern.matcher(text);
        while (matcher.find()) {
            if (matcher.group().contains(" – ")) {
                String instr = matcher.group().split(" – ")[0].split("\\.")[1].strip().split("\\s")[0];
                pageNumberMap.put(instr, Integer.parseInt(matcher.group(1)));
            }
        }
    }
}
